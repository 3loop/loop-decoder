---
title: Getting Started
description: Quick start guide on using the Loop Decoder
---

import { Content as MemoryAbiLoader } from '../../components/memory-abi-loader.md'
import { Content as MemoryContractLoader } from '../../components/memory-contract-loader.md'
import { Content as RpcProvider } from '../../components/rpc-provider.md'

## Installation

```sh
npm i @3loop/transaction-decoder viem effect
```

### Overview

To begin using the Loop Decoder, you must provide three components:

- RPC Provider
- ABI Loader
- Contract Metadata Loader

This guide demonstrates setup using the default in-memory implementations for data loaders. For custom storage solutions, see our [How To Decode Transaction](/guides/decode-transaction/) guide.

### 1. Set up your RPC Provider

Create a `getPublicClient` function that accepts a chain ID and returns an object with [Viem](https://viem.sh/) `PublicClient`.

<RpcProvider />

For detailed configuration options and trace API settings, see the [RPC Provider](/reference/rpc-provider/) documentation.

### 2. Initialize ABI Loader

The `InMemoryAbiStoreLive` provides default ABI loading functionality:

- Fetches ABIs from multiple sources (Etherscan, 4bytes, Openchain, Sourcify)
- Caches results in memory

```ts
import { InMemoryAbiStoreLive } from '@3loop/transaction-decoder/in-memory'
import { ConfigProvider, Layer } from 'effect'

// We use Effect library to provide custom configuration
const Config = ConfigProvider.fromMap(new Map([['ETHERSCAN_API_KEY', 'YourApiKey']]))
const ABILoaderLayer = Layer.setConfigProvider(Config)
const abiStore = InMemoryAbiStoreLive.pipe(Layer.provide(ABILoaderLayer))
```

For a custom implementation, see our [How To Decode Transaction, ABI Loader](/guides/decode-transaction/#abi-loader) guide.

### 3. Initialize Contract Metadata Loader

The `InMemoryContractMetaStoreLive` handles contract metadata resolution:

- Resolves `ERC20`, `ERC721` and `ERC1155` metadata using RPC calls
- Caches results in memory

```ts
import { InMemoryContractMetaStoreLive } from '@3loop/transaction-decoder/in-memory'

const contractMetaStore = InMemoryContractMetaStoreLive
```

For a custom implementation, see our [How To Decode Transaction, Contract Metadata Loader](/guides/decode-transaction/#contract-metadata-loader) guide.

### 4. Final Step

Finally, you can create a new instance of the LoopDecoder class and invoke `decodeTransaction` method with the transaction hash and chain ID:

```ts
import { TransactionDecoder } from '@3loop/transaction-decoder'

const decoder = new TransactionDecoder({
  getPublicClient: getPublicClient,
  abiStore,
  contractMetaStore,
})

const decoded = await decoder.decodeTransaction({
  chainID: 1,
  hash: '0x...',
})
```

## Live Demo

<div style="height: 600px;">
  <iframe
    style="width: 100%; height: 100%; border: 0;"
    src="https://stackblitz.com/github/3loop/loop-decoder/tree/main/sandbox/quick-start?embed=1&file=src/decoder.ts&hideNavigation=1&hideDevTools=true&terminalHeight=1&hideExplorer=1&devtoolsheight=1&ctl=1"
  ></iframe>
</div>
